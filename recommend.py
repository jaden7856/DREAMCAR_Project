# -*- coding: utf-8 -*-
"""crawler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1byeTRThLR6kr7xw1GUBOwQAr85K2AVlS
"""
# -*- coding: utf-8 -*-
from urllib.request import urlopen, Request
import urllib
import bs4
from datetime import *
from pytz import timezone

import numpy as np
import pandas as pd
import random
import collections


# print('현재 ' + location + ' 온도는 ' + temperature + '도 입니다.')
# print('현재 ' + location + ' 날씨는 ' + weather + ' 입니다.')

# 요일
def week():
    t = ['월', '화', '수', '목', '금', '토', '일']
    r = datetime.today().weekday()
    if t[r] in ['금', '토', '일']:
        day = [t[r] + '요일']
        weekend = ['토요일', '일요일', '스트레스', '여유', '불금'] + day
        result = weekend
    else:
        day = [t[r] + '요일']
        weekday = ['으악', '월요병', '월요일', '잔잔한', '평일'] + day
        result = weekday
    return result


# 날씨
def weather(loc):
    location = str(loc)
    enc_location = urllib.parse.quote(location + '+날씨')

    url = 'https://search.naver.com/search.naver?ie=utf8&query=' + enc_location

    req = Request(url)
    page = urlopen(req)
    html = page.read()
    soup = bs4.BeautifulSoup(html, 'html5lib')

    weather = soup.find('ul', class_='info_list').find('p', class_='cast_txt').text.split(',')[0]
    # temperature = soup.find('p', class_='info_temperature').find('span', class_='todaytemp').text

    return weather


# 계절 봄(3~5월), 여름(6~8월), 가을(9~11월), 겨울(12~2월)
def season():
    spring = ['사랑', '데이트', '달달한', '썸', '벚꽃', '발', '봄', '봄날', '설렘', '봄노래', '산책', '나들이']
    summer = ['시원한', '더위', '청량', '바다', '여름', '청량한', '바캉스', '열대야', '해변', '여름밤']
    autumn = ['산책', '가을밤', '추억', '이별', '낙엽', '쓸쓸', '가을감성', '감성', '발라드']
    winter = ['겨울', '따뜻한', '추움', '따뜻한', '겨울감성', '쌀쌀한', '추위', '12월', '11월', '찬바람', '겨울밤']

    snow = ['첫눈', '눈오는날', '크리스마스', '캐롤', '12월', '눈', '성탄절']
    rain = ['비오는날듣기좋은노래', '비오는날', '장마', '우울', 'rain', '소나기', '우산', '흐린날', '비']

    now = datetime.now(timezone('Asia/Seoul'))
    month = now.month
    if month in [12, 1, 2]:
        result = winter
    elif month in [3, 4, 5]:
        result = spring
    elif month in [6, 7, 8]:
        result = summer
    elif month in [9, 10, 11]:
        result = autumn
    elif weather('다동') == '비':
        result = rain
    elif weather('다동') == '눈':
        result = snow

    return result


# 시간
def time():
    morning = ['출근길', '아침', '힐링', '출근길', '월요병', '스트레스', '시작', '잔잔한', '월요일', '지하철', '버스', '등교', '노동요', '일', '모닝콜', '상쾌한']
    afternoon = ['잔잔한', '버스킹', '산책', '직장인', '포근한', '시간', '낮잠', '밝은', '기분전환', '센스선곡', '힐링', '점심', '활기차게', '소소한']
    evening = ['오후', '감성', '휴식', '힐링', '잔잔한', '저녁', '밤', '퇴근길', '새벽', '위로', '저녁', '퇴근', '버스', '스트레스', '분위기', '지하철', '집']
    dawn = ['밤새벽', '밤', '잔잔한', '감성', '휴식', '이별', '슬픔', '추억', '회상', '카페', '분위기', '새벽감성', '몽환', '혼자', '센치', '잠들기전', '새벽']

    now = datetime.now(timezone('Asia/Seoul'))
    hour = now.hour
    if hour in list(range(0, 7)):
        result = dawn
    elif hour in list(range(7, 12)):
        result = morning
    elif hour in list(range(12, 18)):
        result = afternoon
    else:
        result = evening
    return result


# 감정 :
def emotion(emo, my_tag):
    happy = ['사랑', '설렘', '행복', '연애', '고백', '웃음', '두근두근', '휴식', '평화', 'Like',
             '힐링', '설레임', '여행', '데이트', '카페', '인생', '심쿵', '연인', '미소', '행복한', '트렌디',
             '기분좋은', '밝은', '즐거운', '따뜻한', '재밌는', '기분좋은곡', '밝음', '엽기', '다잘될거야']
    angry = ['스트레스', '기분전환', '분노', '스트레스해소', '짜증날때', '빡칠때', '짜증', '열받을때', '회사',
             '꿀꿀할때', '가슴이답답할때', '질주', '분노표출', '화날때', '힐링', '기분안좋을때', '긍정적',
             '답답할때', '화', '욕하고싶을때', '퇴사']
    neutral = my_tag

    if emo == 'happy':
        result = happy
    elif emo == 'angry':
        result = angry
    else:
        result = neutral

    return result


# 각 변수에 맞게 random한 20개의 tag list return
def random_tag(emotionplst, weather, week, time, my_tag, emo):
    tag_out = []
    if emo in ['happy', 'angry']:
        tag_out += random.sample(emotionplst, 11)
        tag_out += random.sample(weather, 3)
        tag_out += random.sample(week, 3)
        tag_out += random.sample(time, 3)

    elif emo == 'neutral':
        tag_out += my_tag
        tag_out += random.sample(weather, 3)
        tag_out += random.sample(week, 3)
        tag_out += random.sample(time, 3)

    return tag_out


def run(emo, my_tag):
    drowsy = ['오후', '운전', '기분전환', '댄스', '헬스', '운동', '다이어트', '춘곤증', '추석',
             '귀경길', '신나는', '고속도로', '운전', '졸릴때', '또라이', '신나는', '신나는음악', '애창곡',
             '설명절', '귀성길', '댄스곡', 'EDM']

    if emo == 'drowsy':
        total = drowsy
    else:
        w = week()
        s = season()
        t = time()
        e = emotion(emo, my_tag)
        total = random_tag(e, s, w, t, my_tag, emo) # 한개의 list에 20개 tag

    return total


def variable(song_csv, train_json, my_id):
    song_meta = pd.read_csv(song_csv, index_col=0)

    data = pd.read_json(train_json, typ='frame', encoding="utf-8")

    # personal playlist
    my_list = data[data["id"] == my_id]

    # artist name, song title list
    artist = zip(song_meta.artist_name_basket, song_meta.song_name)

    # return part
    song_id = dict(zip(song_meta["id"], artist))
    genre_id = dict(zip(song_meta["id"], song_meta.genre))
    conv_song = dict(zip(data["id"], data.songs))
    my_tag = my_list.tags.tolist()[0]  # personal playlist tag
    my_song = my_list.songs.tolist()[0]  # personal playlist song

    return data, my_tag, my_song, song_id, genre_id, conv_song


def sub_recommend(data, total, my_song, conv_song, genre_id):
    # data tag list
    tags = data.tags.tolist()

    len_t = []
    for i, tages in enumerate(tags):
        # 'total' with 전체 plylist의 tag 중 같은 tag의 수
        len_t.append(len(list(set(tages).intersection(total))))

    # playlist의 id와 중복 tag 수 dict
    ply_tag = dict(zip(data["id"], len_t))
    # dict에서 높은 순서로 나열후 playlist 100개 출력
    ply_tag = sorted(ply_tag.items(), key=(lambda x: x[1]), reverse=True)[:100]

    # playlist의 id 추출
    p_id = list(map(lambda x: x[0], ply_tag))

    plylst = []
    for i in p_id:
        # 각 playlist마다 song 출력
        plylst.append(conv_song[i])

    # 노래 list를 주면 노래를 장르로 변경
    def best_genre(song_list):
        s_g = []
        for o, sid in enumerate(song_list):
            s_g.append(genre_id[sid])

        # 노래에서 장르로 바뀐 것을 count하여 많이 나온 순으로 나열
        count = collections.Counter(s_g).most_common()

        best_genre = []
        for gen in count:
            best_genre.append(gen[0])

        return best_genre

    plylst_genre = []
    for i in range(len(plylst)):
        # 100개의 각각의 plylist 노래에 장르수가 많은순으로 나열
        plylst_genre.append(best_genre(plylst[i]))

    # 개인 플레이리스트 노래들의 장르
    my_genre = best_genre(my_song)

    st = []
    for i in range(len(plylst_genre)):
        # 100개의 plylist의 장르와 개인 plylist 장르간에 중복횟수
        st.append(len(list(set(plylst_genre[i]).intersection(my_genre))))

    # 100개의 plylist의 id와 중복횟수 dict 저장
    rec = dict(zip(p_id, st))
    # 중복횟수 많은 순으로 나열하여 그중에 가장 중복횟수가 많은 plylist 출력
    sub_recom = sorted(rec.items(), key=(lambda x: x[1]), reverse=True)[0][0]

    return sub_recom


def recommendtaion(sub_recom, data):
    idx = (data[data.id == sub_recom].index[0]) // 100  # ex) 3295 -> 32
    r = str(data[data.id == sub_recom].index[0])    # ex) '3295'

    if idx == 0:
        cos_tag = np.load(
            #'E:/Final_Project/arena_data/cos_tag_split/' + str(idx) + '_99' + '.npy')
            'C:/Users/User/Desktop/cos_tag_split/' + str(idx) + '_99' + '.npy')

    else:
        cos_tag = np.load(
            #'E:/Final_Project/arena_data/cos_tag_split/' + str(idx) + '00_' + str(idx) + '99' + '.npy')
            'C:/Users/User/Desktop/cos_tag_split/' + str(idx) + '00_' + str(idx) + '99' + '.npy')

    d = int(r[-2:])  # ex) '3295' -> 95
    similarities = {}
    # Now we'll sort each element in cosine_similarities and get the indexes of the songs. 
    similar_indices = cos_tag[d].argsort()[:-30:-1]
    # After that, we'll store in similarities each name of the 50 most similar songs.
    # Except the first one that is the same song.
    similarities[data['id'].iloc[int(r)]] = [(data['id'][x], cos_tag[d][x],
                                              data['plylst_title'][x],
                                              data['tags'][x]) for x in similar_indices][1:]

    # 추천된 playlist들중에 상위 10개에서 랜덤 1개 출력
    a = random.sample(similarities[sub_recom][:10], 1)
    ply_id = a[0][0]
    ply_cos = a[0][1]
    ply_title = a[0][2]
    ply_tag = a[0][3]

    return ply_id, ply_cos, ply_title, ply_tag


def main(song_csv, train_json, emo, my_id):
    data, my_tag, my_song, song_id, genre_id, conv_song = variable(song_csv, train_json, my_id)
    total = run(emo, my_tag)
    sub_recom = sub_recommend(data, total, my_song, conv_song, genre_id)
    ply_id, ply_cos, ply_title, ply_tag = recommendtaion(sub_recom, data)

    # s = conv_song[ply_id]
    #
    # song_list = []
    # for so in s:
    #     song_list.append(song_id[so])

    print(total)
    print(ply_cos)

    return ply_title, ply_tag

if __name__ == "__main__":
    song_csv = "C:/Users/User/Google 드라이브/Pycharm/Car_Project/arena_data/song.csv"
    train_json = 'C:/Users/User/Google 드라이브/Pycharm/Car_Project/arena_data/data.json'
    my_id = 126993
    ply_title, ply_tag = main(song_csv, train_json, 'happy', my_id)
    print(ply_title)